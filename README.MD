####################################################

#1、程序开发目的

基于网站路径【深入】检测目录下的敏感文件。

目前主要关注于根目录下的备份文件扫描,

对于根目录下其他文件也可以直接添加字典扫描。

支持自动分割带有多个目录层级的为多个基本URL进行扫描,但暂不支持自动递归目录进行扫描。

##1.1、直接需求:
    1、输入URL自动进行备份文件等根目录敏感文件扫描。

##1.2、细节需求：
    1、能够根据特定的规则生成动态字典文件,主要是实现动态替换(日期、域名、路径等）属性。
    2、能够根据响应情况,自动筛选出不存在的文件,减少扫描过程中的误报。
    3、能够自动处理字典的编码逻辑,扫描出国内常见的中文命名。
    4、能够记录程序的详细日志输出,辅助单独的结果文件进行判断。

#1.3新增功能
    1、添加字典频率筛选功能,仅加载频率在某一个阈值范围的字典
    2、支持简单分析命中的URL,并自动加入hit_xxx.lst加入规则字典

#1.4其他考虑
    添加结果关键字匹配,过滤一些确定没有的页面
    添加指定字典或排除字典文件的功能,默认调用的字典太多
    考虑将字典固定到一个文件内,更好的进行命中添加。

####################################################

#2、工具特点
    
##2.1、扫描字典突出优势
    1、根据支持多种动态规则来动态生成扫描路径
       (通过基本变量替换+因变量替换+解析正则规则+解析自定义规则实现）。
       (由于规则解析的格式需要,因此对字典内容存在要求,具体规则编写办法参考下文)
       (因变量支持域名、路径和自定义，基本变量支持从文件中读取替换。)


    2、扫描字典添加支持多种方案,不同的需求可以添加到不同的字典目录中。
        (支持添加直接拼接到URL后的字典+支持笛卡尔组合的目录和字典）
        (不同目录下的字典在拼接到URL时,有不同的处理方式，具体参考下文)

##2.2、HTTP请求配置
    1、对输入的目标URL自动进行格式分析和L自动访问检测和协议头自动判断功能。
       简单输入——URL或URL文件,支持检测目标是否可以访问
       扩展输入——自动分析处理HOST格式[IP:PORT,Domain],自动检测分析请求协议
    2、默认启用中文路径或特殊字符会添加分别以【gb2312、utf-8】作为基础编码进行URL编码。
    3、请求时大量的参数配置在setting.py中有描述和支持,用户可自定义大部分的参数配置。
    4、对已经访问过的URL可以进行过滤,不进行多次扫描。
    5、对输出的多级URL可选差分为多个目标URL。
        情景1：直接获取用户输入的URL作为目标,拼接URL+字典路径进行扫描。 
        情景2：分别获取http://HOST:PORT、http://HOST:PORT/XXX/、http://HOST:PORT/XXX/YYY/等多个层级作为目标，然后拼接目标进行扫描。
    6、支持自动化进行Refer头更新、HOST头更新,及配置Cookie等请求参数


##2.3、HTTP响应配置
    1、有效响应结果筛选可以选择多种筛选方案:
        1、基本判断：
            1、响应状态码丢弃列表，判断响应状态码是否在丢弃列表内。
        2、动态判断：
            1、响应内容前10字节，判断是否与随机测试路径响应内容的前十字节是否相同。
            2、响应内容Hash，判断是否与随机测试路径的响应全文Hash相同。
            3、响应内容实际返回大小，判断是否与随机测试路径的响应内容的实际返回大小相同。
            4、响应内容Content-Length，判断是否与随机测试路径的响应的Content-Length相同。
            5、响应内容Title，判断是否与随机测试路径的响应的标题字段相同。

更多使用配置参数详情参照 [setting.py]
####################################################
#3、字典目录结构

1、所有字典默认存放在dict目录,其目录下存在4个目录(base,direct,floders,files),分别用于存放不同类型的字典文件。

2、字典文件的后缀默认设置为【.lst】,该参数在setting.py中可以自定义,默认只读取目录下该后缀的字典文件。

3、如有需求,后续可考虑使用sqlite存储字典数据库,但是手动修改会变得复杂.

##3.1、dict/base目录
    base目录存放基础变量字典,每个基础变量字典用于自动替换字典规则中的对应基础变量(由文件名提取)。
  
###3.1.1 base目录下字典文件命名和产生的基本变量:
    字典文件名 file_name.lst ==> 删除后缀 == > file_name ==>变为基本替换规则的键 == > %file_name%

    对应关系:
    文件名【xxx.lst】其中的内容,会在初次规则渲染时【用字典内容】替换字典规则中的【%xxx%】变量

    简单示例情景: 
    direct目录下某个文件字典存在一行字典规则/admin%backup_ext%
    base目录下存在文件【backup_ext.lst】文件,该文件每一行内容是一个后缀【.rar、.zip、.tar.gz、】

###3.1.2、base目录下字典文件的大致处理过程:

    1、base目录下的字典文件【backup_ext.lst】会从文件名会提取出【%backup_ext%】变量用于替换。

    2、字典文件内的容会在读取后转变为一个正则表达式【(\.rar|\.zip|\.gz|\.tar)】

    3、字典文件名与内容会转变为一个替换字典 {"%backup_ext%":"(\.rar|\.zip|\.gz|\.tar)"}

    3、在规则渲染时,【/admin%backup_ext%】规则,会变为【/admin.rar、/admin.zip、/admin.tar.gz】

###3.1.3、base字典添加注意事项:

    1、base字典目录下存放最基础的变量字典,每一行支持动态替换规则，不支持基础变量和因变量。

    2、base字典目录下的字典文件命名和其他目录下的字典规则的基础变量有强关联性。

##3.2、dict/direct目录

###3.2.1 direct目录下的字典介绍:
    direct目录下的文件名无特殊的命名要求,会读取目录下所有符合定义的自定后缀的文件内容。

###3.2.2、direct目录下的字典处理:
    dict/direct 目录存放的字典的规则内容会被直接添加到URL之后。

##3.3、dict/floders 和 dict/files目录

###3.3.1 dict/floders 和 dict/files目录下的字典介绍:

    dict/floders目录下仅仅存放目录字典文件,字典的每一行是一个目录,字典文件名命名除后缀外没有要求。

    dict/files 目录下仅仅存放文件名字典,字典的每一行是一个文件名,字典文件名命名除后缀外没有要求。

###3.2.2、dict/floders 和 dict/files目录下的字典处理:
    
    1、从floders目录下的所有文件读取到一个floder列表
    
    2、从files目录下的所有文件读取到一个file列表

    3、对floder列表和file列表,会以/{floder}/{file}的格式进行遍历拼接(笛卡尔集)。
####################################################
#4、字典文件内容编写规则

##4.1、基础变量介绍
    字典内以 %变量名% 格式出现,变量名是从base目录下的字典文件名中动态获取的。
    基础变量会在【初次渲染时】被替换为字典文件的内容。
 
    基本变量替换字典示例：
    backup_ext.lst字典文件衍生规则: 
    {'%backup_ext%': '(\\.rar|\\.zip|\\.gz|\\.tar|\\.tgz|\\.tar\\.gz|\\.7z|\\.z|\\.bz2|\\.tar\\.bz2|\\.iso|\\.cab)'}

##4.2、因变量介绍: 
    字典内以 %%变量名%% 格式出现,变量名在代码中定义,变量对应的内容获取函数也在代码中定义。
    目前内置有【%%domain%%、%%path%%】两个变量,会分别获取域名相关的列表和路径相关的列表。
    因变量会在【二次渲染时】被替换为从URL中动态获取的内容。

    因变量替换字典示例:
    解析 https://www.baidu.com 得到因变量字典: 
    {'%%domain%%': '(baidu|baidu_com|www\\.baidu\\.com|baidu\\.com|www_baidu_com)'}

##4.3、动态替换规则: 

     动态替换规则指字典内以 {规则分类=规则类型(附加参数):实际解析部分}$ 格式出现的字符串。

     因此在字典中使用规则引擎，需要以 { 括号开头，并以 }$ 结尾，

     替换规则有【date、int、str、re】四种规则分类,每种规则可能存在多种规则类型。

     不同的规则的【实际解析部分】有不同的编写格式要求。


| 规则      |    说明 |
| :-------- |:--------|
| re   | 正则引擎 |
| int  | 整数 |
| str  | 字符 |
| date | 日期 |

###4.3.1、date类型替换规则: 
     
        {date=日期类型:日期开始-日期结束}$

        规则类型:year(年) 2005-2015
        规则示例:RuleParser('{date=year:2017-2018}$').parse()
        规则输出:['2017', '17', '2018', '18']

        规则类型:mon(月) 1-12
        规则示例:RuleParser('{date=mon:9-10}$').parse()
        规则输出:['9', '09', '10']

        规则类型:day(日) 0-30 
        规则示例:RuleParser('{date=day:9-10}$').parse()
        规则输出:['9', '09', '10']

        规则类型:year_mon(年月) 200501-201512
        规则示例:result = RuleParser('{date=year_mon:201709-201712}$').parse() 
        规则输出:['201709', '20179', '201710', '201711', '201712']

        规则类型:mon_day(月日) 0101-1231
        规则示例: result = RuleParser('{date=mon_day:0928-1003}$').parse() 
        规则输出:['0930', '1001', '0929', '09-29', '1003', '10-01', '09-30', '10-02', '10-03', '1002']

        规则类型:year_mon_day(年月日) 20050101-20151231
        规则示例:RuleParser('{date=year_mon_day:20170111-20170112}$').parse() 
        规则输出:['170112', '20170112', '17-01-12', '2017-01-12']

        规则类型:mon_day_year(月日年) 01012005-12312015
        规则示例:RuleParser('{date=mon_day_year:01112017-01122017}$').parse() 
        规则输出:['2017-01-12', '17-01-12', '170112', '20170112']

        PS：日期会出现的子分类情况，初始位数补充0911,911

###4.3.2、int类型替换规则:
        {int=数字类型#元素长度$步长:数字开始-数字结束}$

        规则类型:series(正常按照顺序递进,支持$步长选项)
        规则示例:RuleParser('{int=series:1-5}$').parse() 
        规则输出:['1', '2', '3', '4', '5']
        规则示例:result = RuleParser('{int=series$2:1-15}$').parse() #使用步长选项
        规则输出:['1', '3', '5', '7', '9', '11', '13', '15']
        规则提示:
        仅series类型支持步长
        仅series类型长度选项没有实际用处

        规则类型:digits(连号数字)
        规则示例:RuleParser('{int=digits#3:1-5}$').parse() 
        规则输出:['123', '321', '234', '432', '345', '543']
        规则提示:#3表示数字的长度为3

        规则类型:overlap(重叠数字)
        规则示例:RuleParser('{int=overlap#3:1-9}$').parse() 
        规则输出:['111', '222', '333', '444', '555', '666', '777', '888', '999']
        规则示例:RuleParser('{int=overlap#3:11-22}$').parse() 
        规则输出:['111111', '121212', '131313', '141414', '151515', '161616', '171717', '181818', '191919', '202020', '212121', '222222']
        规则提示:#3表示元素的个数为3


###4.3.3、str类型替换规则: 
        {str=字符类型#元素长度:字符开始-字符结束}$

        规则类型:letters(按照顺序递进)
        规则示例:RuleParser('{str=letters#3:a-d}$').parse()
        规则输出:['abc', 'bcd']
        规则提示:#3表示字母的长度为3

        规则类型:overlap(重叠字母)
        规则示例:RuleParser('{str=overlap#3:A-D}$').parse() 
        规则输出:['AAA', 'BBB', 'CCC', 'DDD']
        规则提示:#3表示元素的个数为3

###4.3.4、re类型替换规则: 
    re是正则解析器,会根据正则生成符合正则规则的字符串,是最常用的规则。
    已知的正则解析生成器有 exrex、sre_yield,解析结果是相同的,只不过有不同的解析算法。

    {re=引擎类型:正则表达式}$

    引擎类型:exrex(exrex正则解析引擎)
    规则示例:RuleParser('{re=exrex:(201[7-9]{1}[1]{1}[8-9]{1})}$').parse() 
    规则输出:['201718', '201719', '201818', '201819', '201918', '201919']
    
    引擎类型:sre_yield(sre_yield正则解析引擎)
    规则示例:RuleParser('{re=sre_yield:(201[7-9]{1}[1]{1}[8-9]{1})}$').parse()  
    规则输出:['201718', '201818', '201918', '201719', '201819', '201919']


##4.4 字典规则编写注意事项
    1、字典内的每一行规则最多支持【两个%基本变量%】、【两个%%因变量%%】
    2、字典内的每一行规则最多 【一个】解析规则
    3、组合目录字典和组合文件字典在进行初次渲染时,会分别进行一次渲染(1-1和1-2次),每一行字典也支持如上两项。

##4.5 字典规则调试和验证
    1、allow_rule_verify_x_x配置参数指定 是否验证x_x次渲染规则
    在渲染验证模式下,如果一行字典规则有问题,会显示错误提示,并删除该条规则。
    如果不在渲染验证模式下,会对所有字典一次性进行渲染,有错误的话会直接导致程序停止。
    第一次运行建议验证,如果无任何错误后续就无需验证,在日志文件内也会记录有访问过哪些URL。

    2、show_render_result_x_x配置参数指定 是否输出x_x次渲染的结果
     越后面次数的渲染,处理的字典列表越大,输出的结果越多,所以对后面的渲染最好不用输出。

    3、实际使用时,如果前三次的规则没有问题,那后面的规则渲染也不会有问题的。

##4.6 规则报错示例:
    错误内容:
    [22:30:20] [-] 第 1-1 次规则渲染逐条解析发生错误,每条字典规则仅支持单个{xx=xx:xxx}$格式规则!!! 
    Rule: /{date=year:2021-2022}$-{re=exrex:([ABC])(%backup_ext%)}$ 
    Error: too many values to unpack (expected 2)
    错误原因:
    本规则内带有了两条解析规则,所以导致了错误。

###4.7其他字典规则
    1、支持注释,对#号开头的行,和频率字符串后面的#号都会进行删除
    
####################################################
#5、其他使用与配置信息

    python3 DynaWeakFileScan.py -h
    
    usage: DynaWeakFileScan.py [-h] [-u TARGET] [-f TARGET_FILE] [-p PROXY] [-t thread] [-d] [-v]

    optional arguments:
      -h, --help       show this help message and exit
      -u TARGET        指定扫描目标URL, Example: http://www.baidu.com
      -f TARGET_FILE   指定扫描目标URL文件, Example: target.txt
      -p PROXY         指定请求时使用的HTTPS或SOCKS5的代理, Example: http://127.0.0.1:8080 or socks5://127.0.0.1:1080
      -t thread        指定多线程池的最大线程数
      -d debug         显示程序运行时的所有调试信息,默认关闭
      -v version       显示程序当前版本号

    Examples:
      python3 DynaWeakFileScan.py -u http://www.baidu.com
      python3 DynaWeakFileScan.py -f target.txt
      python3 DynaWeakFileScan.py -f target.txt -p http://127.0.0.1:8080

      其他控制细节参数请通过config.py进行配置

      T00L Version: Ver 0.7 2022-99-99 00:00

####################################################
#6、程序参考说明
    渲染规则部分主要参考ring04的weakfilescan,另外修复Python3环境的一些错误。
    weakfilescan原版请访问https://github.com/ring04h/weakfilescan
####################################################